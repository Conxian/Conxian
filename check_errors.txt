note: using deployments/default.simnet-plan.yaml
error: Failed to lex input remainder: ''.sip-010-ft-trait)
(use-trait bond-trait '.bond-trait)

(impl-trait '.bond-trait)
(impl-trait '.sip-010-ft-trait)

(define-fungible-token tokenized-bond)

(define-constant ERR_UNAUTHORIZED u201)
(define-constant ERR_NOT_YET_MATURED u202)
(define-constant ERR_ALREADY_MATURED u203)
(define-constant ERR_NO_COUPONS_DUE u204)
(define-constant ERR_BOND_NOT_ISSUED u205)
(define-constant ERR_ALREADY_ISSUED u210)

(define-data-var token-name (string-ascii 32) "Tokenized Bond")
(define-data-var token-symbol (string-ascii 10) "BOND")
(define-data-var token-decimals uint u8)
(define-data-var token-uri (optional (string-utf8 256)) none)

(define-data-var bond-issued bool false)
(define-data-var issue-block uint u0)
(define-data-var maturity-block uint u0)
(define-data-var coupon-rate uint u0)
(define-data-var coupon-frequency uint u0)
(define-data-var face-value uint u0)
(define-data-var payment-token-contract (optional principal) none)
(define-data-var contract-owner principal tx-sender)
(define-data-var total-supply uint u0)

(define-map last-claimed-coupon { user: principal } { period: uint })

(define-public (issue-bond
    (name (string-ascii 32))
    (symbol (string-ascii 10))
    (decimals uint)
    (initial-supply uint)
    (maturity-in-blocks uint)
    (coupon-rate-scaled uint)
    (frequency-in-blocks uint)
    (bond-face-value uint)
    (payment-token-address principal)
  )
  (begin
    (asserts! (is-eq tx-sender (var-get contract-owner)) (err ERR_UNAUTHORIZED))
    (asserts! (not (var-get bond-issued)) (err ERR_ALREADY_ISSUED))

    (var-set token-name name)
    (var-set token-symbol symbol)
    (var-set token-decimals decimals)
    (var-set issue-block block-height)
    (var-set maturity-block (+ block-height maturity-in-blocks))
    (var-set coupon-rate coupon-rate-scaled)
    (var-set coupon-frequency frequency-in-blocks)
    (var-set face-value bond-face-value)
    (var-set payment-token-contract (some payment-token-address))

    (try! (ft-mint? tokenized-bond initial-supply (var-get contract-owner)))
    (var-set total-supply initial-supply)

    (var-set bond-issued true)
    (ok true)
  )
)

(define-public (claim-coupons (payment-token principal))
  (let (
      (user tx-sender)
      (last-period (default-to u0 (get period (map-get? last-claimed-coupon { user: user }))))
      (current-period (/ (- block-height (var-get issue-block)) (var-get coupon-frequency)))
      (balance (ft-get-balance tokenized-bond user))
    )
    (asserts! (var-get bond-issued) (err ERR_BOND_NOT_ISSUED))
    (asserts! (< block-height (var-get maturity-block)) (err ERR_ALREADY_MATURED))
    (asserts! (> current-period last-period) (err ERR_NO_COUPONS_DUE))

    (let (
        (periods-to-claim (- current-period last-period))
        (coupon-per-token-per-period (/ 
          (* (var-get face-value)
            (* (var-get coupon-rate) (var-get coupon-frequency))
          )
          u525600000
        ))
        (total-coupon-payment (* balance (* periods-to-claim coupon-per-token-per-period)))
      )
      (asserts!
        (is-ok (contract-call? payment-token transfer total-coupon-payment tx-sender user))
        (err u400)
      )
      (map-set last-claimed-coupon { user: user } { period: current-period })
      (ok total-coupon-payment)
    )
  )
)

 (define-public (redeem-at-maturity (payment-token principal))
  (let (
      (user tx-sender)
      (balance (ft-get-balance tokenized-bond user))
      (maturity (var-get maturity-block))
    )
    (asserts! (var-get bond-issued) (err ERR_BOND_NOT_ISSUED))
    (asserts! (>= block-height maturity) (err ERR_NOT_YET_MATURED))

    (let (
        (last-claim-period (default-to u0 (get period (map-get? last-claimed-coupon { user: user }))))
        (maturity-period (/ (- maturity (var-get issue-block)) (var-get coupon-frequency)))
        (periods-to-claim (if (> maturity-period last-claim-period)
          (- maturity-period last-claim-period)
          u0
        ))
        (coupon-per-token-per-period (/ 
          (* (var-get face-value)
            (* (var-get coupon-rate) (var-get coupon-frequency))
          )
          u525600000
        ))
        (final-coupon-payment (* balance (* periods-to-claim coupon-per-token-per-period)))
        (principal-payment (* balance (var-get face-value)))
        (total-payment (+ final-coupon-payment principal-payment))
      )
      (asserts! (> balance u0) (err u0))
      (asserts!
        (is-ok (contract-call? payment-token transfer total-payment tx-sender user none))
        (err u400)
      )
      (try! (ft-burn? tokenized-bond balance user))
      (var-set total-supply (- (var-get total-supply) balance))
      (map-set last-claimed-coupon { user: user } { period: maturity-period })
      (ok {
        principal: principal-payment,
        coupon: final-coupon-payment,
      })
    )
  )
)

(define-public (transfer
    (amount uint)
    (sender principal)
    (recipient principal)
    (memo (optional (buff 34)))
  )
  (begin
    (asserts! (is-eq sender tx-sender) (err u4))
    (try! (ft-transfer? tokenized-bond amount sender recipient))
    (ok true)
  )
)

;; --- SIP-010 and helper read-only/public functions ---

(define-read-only (get-balance (who principal))
  (ok (ft-get-balance tokenized-bond who))
)

(define-read-only (get-total-supply)
  (ok (var-get total-supply))
)

(define-read-only (get-decimals)
  (ok (var-get token-decimals))
)

(define-read-only (get-name)
  (ok (var-get token-name))
)

(define-read-only (get-symbol)
  (ok (var-get token-symbol))
)

(define-read-only (get-token-uri)
  (ok (var-get token-uri))
)

(define-public (set-token-uri (value (optional (string-utf8 256))))
  (begin
    (asserts! (is-eq tx-sender (var-get contract-owner)) (err ERR_UNAUTHORIZED))
    (var-set token-uri value)
    (ok true)
  )
)

(define-read-only (get-payment-token-contract)
  (ok (var-get payment-token-contract))
)
'
error: Failed to lex input remainder: ''.pool-trait)
(use-trait sip10-trait '.sip-010-ft-trait)

(define-constant ONE u1)
(define-constant TWO u2)
(define-constant TEN u10)

(impl-trait '.pool-trait)
(impl-trait '.sip-010-ft-trait)

;; Private helper functions
(define-private (min (a uint) (b uint))
  (if (< a b) a b))

;; Use math library for square root
(define-constant MATH_CONTRACT 'ST3PPMPR7SAY4CAKQ4ZMYC2Q9FAVBE813YWNJ4JE6.math-lib-advanced)

(define-private (sqrt (n uint))
  (match (contract-call? MATH_CONTRACT sqrt-fixed n)
    result (ok result)
    error (err u0)  ;; Fallback to 0 on error
  ))

;; Constants
(define-constant ERR_UNAUTHORIZED u1001)
(define-constant ERR_PAUSED u1002)
(define-constant ERR_INSUFFICIENT_LIQUIDITY u3001)
(define-constant ERR_SLIPPAGE_TOO_HIGH u3002)
(define-constant ERR_INVALID_AMOUNT u3003)
(define-constant ERR_DEADLINE_PASSED u3004)
(define-constant ERR_INSUFFICIENT_SHARES u3005)
(define-constant ERR_ZERO_LIQUIDITY u3006)
(define-constant ERR_NOT_INITIALIZED u3007)

(define-constant PRECISION u100000000) ;; 8 decimals
(define-constant MIN_LIQUIDITY u1000)

;; Data variables
(define-data-var token-a (optional principal) none)
(define-data-var token-b (optional principal) none)
(define-data-var reserve-a uint u0)
(define-data-var reserve-b uint u0)
(define-data-var total-supply uint u0)
(define-data-var lp-fee-bps uint u30) ;; 0.3%
(define-data-var protocol-fee-bps uint u5) ;; 0.05%
(define-data-var paused bool false)
(define-data-var factory principal tx-sender)

;; Maps
(define-map lp-balances principal uint)
(define-map collected-protocol-fees principal uint) ;; token -> collected fees
(define-map cumulative-prices (string-ascii 16) uint) ;; "price-a" or "price-b" -> cumulative price
(define-map last-update-time (string-ascii 16) uint)

;; Pool performance tracking
(define-map daily-stats (string-ascii 32) (tuple (volume uint) (fees uint) (trades uint)))

;; Read-only functions
(define-read-only (get-reserves)
  (ok (tuple (reserve-a (var-get reserve-a)) 
             (reserve-b (var-get reserve-b)))))

(define-read-only (get-fee-info)
  (ok (tuple (lp-fee-bps (var-get lp-fee-bps)) 
             (protocol-fee-bps (var-get protocol-fee-bps)))))

(define-read-only (get-price)
  (let ((reserve-a-val (var-get reserve-a))
        (reserve-b-val (var-get reserve-b)))
    (if (and (> reserve-a-val u0) (> reserve-b-val u0))
        (ok (tuple (price-x-y (/ (* reserve-b-val PRECISION) reserve-a-val))
                   (price-y-x (/ (* reserve-a-val PRECISION) reserve-b-val))))
        (ok (tuple (price-x-y u0) (price-y-x u0))))))

(define-read-only (get-total-supply)
  (ok (var-get total-supply)))

 (define-read-only (get-token-a)
  (match (var-get token-a)
    token (ok token)
    ERR_NOT_INITIALIZED))

 (define-read-only (get-token-b)
  (match (var-get token-b)
    token (ok token)
    ERR_NOT_INITIALIZED))

(define-read-only (get-lp-balance (user principal))
  (default-to u0 (map-get? lp-balances user)))

(define-read-only (get-pool-performance)
  (let ((today (/ block-height u144))) ;; Approximate daily blocks
    (ok (tuple (volume-24h u0) (fees-24h u0)))))  ;; Simplified for enhanced deployment

;; Private functions
;; Calculate output amount for constant product formula with fees
(define-private (calculate-swap-amount (amount-in uint) (reserve-in uint) (reserve-out uint))
  (let ((amount-in-with-fee (- amount-in (/ (* amount-in (var-get lp-fee-bps)) u10000)))
        (numerator (* amount-in-with-fee reserve-out))
        (denominator (+ reserve-in amount-in-with-fee)))
    (/ numerator denominator)))

;; Update time-weighted average price
(define-private (update-cumulative-prices)
  (let ((current-time block-height)
        (time-elapsed (- current-time 
                        (default-to current-time 
                                   (map-get? last-update-time "price-a")))))
    (if (> time-elapsed u0)
        (let ((price-info (unwrap-panic (get-price))))
          (map-set cumulative-prices "price-a" 
                   (+ (default-to u0 (map-get? cumulative-prices "price-a"))
                      (* (get price-x-y price-info) time-elapsed)))
          (map-set cumulative-prices "price-b"
                   (+ (default-to u0 (map-get? cumulative-prices "price-b"))
                      (* (get price-y-x price-info) time-elapsed)))
          (map-set last-update-time "price-a" current-time)
          (map-set last-update-time "price-b" current-time))
        false)))

;; Update daily trading statistics
(define-private (update-daily-stats (volume uint) (fees uint))
  (let ((today-key "current") ;; Simplified key for enhanced deployment
        (current-stats (default-to (tuple (volume u0) (fees u0) (trades u0))
                                  (map-get? daily-stats today-key))))
    (map-set daily-stats today-key
             (tuple (volume (+ (get volume current-stats) volume))
                    (fees (+ (get fees current-stats) fees))
                    (trades (+ (get trades current-stats) u1))))))

;; Core AMM functions
(define-public (swap-exact-in (amount-in uint) (min-amount-out uint) (x-to-y bool) (deadline uint))
  (let ((current-block block-height)
        (reserve-in (if x-to-y (var-get reserve-a) (var-get reserve-b)))
        (reserve-out (if x-to-y (var-get reserve-b) (var-get reserve-a)))
        (amount-out (calculate-swap-amount amount-in reserve-in reserve-out))
        (protocol-fee (/ (* amount-in (var-get protocol-fee-bps)) u10000))
        (lp-fee (/ (* amount-in (var-get lp-fee-bps)) u10000))
        (total-fee (+ protocol-fee lp-fee)))
    
    ;; Validations
    (asserts! (not (var-get paused)) ERR_PAUSED)
    (asserts! (<= current-block deadline) ERR_DEADLINE_PASSED)
    (asserts! (> amount-in u0) ERR_INVALID_AMOUNT)
    (asserts! (>= amount-out min-amount-out) ERR_SLIPPAGE_TOO_HIGH)
    (asserts! (<= amount-out reserve-out) ERR_INSUFFICIENT_LIQUIDITY)
    
    ;; Update reserves
    (if x-to-y
        (begin
          (var-set reserve-a (+ reserve-in amount-in))
          (var-set reserve-b (- reserve-out amount-out)))
        (begin
          (var-set reserve-b (+ reserve-in amount-in))
          (var-set reserve-a (- reserve-out amount-out))))
    
    ;; Handle protocol fees
    (if (> protocol-fee u0)
        (let ((fee-token (if x-to-y 
                            (unwrap-panic (var-get token-a)) 
                            (unwrap-panic (var-get token-b)))))
          (map-set collected-protocol-fees fee-token
                   (+ (default-to u0 (map-get? collected-protocol-fees fee-token))
                      protocol-fee))
          ;; Skip revenue distributor for enhanced deployment
          true)
        true)
    
    ;; Update statistics
    (update-cumulative-prices)
    (update-daily-stats amount-in total-fee)
    
    ;; Update factory stats - skip for enhanced deployment
    true
    
    ;; Emit event
    (print (tuple (event "swap") 
                  (user tx-sender)
                  (amount-in amount-in)
                  (amount-out amount-out)
                  (fee total-fee)
                  (x-to-y x-to-y)))
    
    (ok (tuple (amount-out amount-out) (fee total-fee)))))

(define-public (add-liquidity (dx uint) (dy uint) (min-shares uint))
  (let ((current-supply (var-get total-supply))
        (reserve-x (var-get reserve-a))
        (reserve-y (var-get reserve-b))
        (shares (if (is-eq current-supply u0)
                    ;; First liquidity provision - use math library for square root
                    (let ((product (* dx dy)))
                      (let ((sqrt-result (unwrap! (contract-call? MATH_CONTRACT sqrt product) (err u3008))))
                        (if (< sqrt-result MIN_LIQUIDITY)
                          (err u3008) ;; ERR_INSUFFICIENT_LIQUIDITY
                          (- sqrt-result MIN_LIQUIDITY))))
                    ;; Subsequent liquidity provision
                    (min (/ (* dx current-supply) reserve-x)
                         (/ (* dy current-supply) reserve-y))))
        (user tx-sender))
    
    ;; Validations
    (asserts! (not (var-get paused)) ERR_PAUSED)
    (asserts! (and (> dx u0) (> dy u0)) ERR_INVALID_AMOUNT)
    (asserts! (>= shares min-shares) ERR_SLIPPAGE_TOO_HIGH)
    
    ;; Update reserves and supply
    (var-set reserve-a (+ reserve-x dx))
    (var-set reserve-b (+ reserve-y dy))
    (var-set total-supply (+ current-supply shares))
    
    ;; Update user LP balance
    (map-set lp-balances user (+ (get-lp-balance user) shares))
    
    ;; Update statistics
    (update-cumulative-prices)
    
    ;; Emit event
    (print (tuple (event "add-liquidity")
                  (user user)
                  (amount-a dx)
                  (amount-b dy)
                  (shares shares)))
    
    (ok (tuple (shares shares) (amount-a dx) (amount-b dy)))))

(define-public (remove-liquidity (shares uint) (min-dx uint) (min-dy uint))
  (let ((current-supply (var-get total-supply))
        (reserve-x (var-get reserve-a))
        (reserve-y (var-get reserve-b))
        (user tx-sender)
        (user-shares (get-lp-balance user))
        (dx (/ (* shares reserve-x) current-supply))
        (dy (/ (* shares reserve-y) current-supply)))
    
    ;; Validations
    (asserts! (not (var-get paused)) ERR_PAUSED)
    (asserts! (> shares u0) ERR_INVALID_AMOUNT)
    (asserts! (>= user-shares shares) ERR_INSUFFICIENT_SHARES)
    (asserts! (and (>= dx min-dx) (>= dy min-dy)) ERR_SLIPPAGE_TOO_HIGH)
    
    ;; Update reserves and supply
    (var-set reserve-a (- reserve-x dx))
    (var-set reserve-b (- reserve-y dy))
    (var-set total-supply (- current-supply shares))
    
    ;; Update user LP balance
    (map-set lp-balances user (- user-shares shares))
    
    ;; Update statistics
    (update-cumulative-prices)
    
    ;; Emit event
    (print (tuple (event "remove-liquidity")
                  (user user)
                  (amount-a dx)
                  (amount-b dy)
                  (shares shares)))
    
    (ok (tuple (amount-a dx) (amount-b dy)))))

;; Enhanced tokenomics integration
(define-public (collect-protocol-fees)
  (let ((fee-a (default-to u0 (map-get? collected-protocol-fees (unwrap-panic (var-get token-a)))))
        (fee-b (default-to u0 (map-get? collected-protocol-fees (unwrap-panic (var-get token-b))))))
    
    ;; Reset collected fees
    (map-set collected-protocol-fees (unwrap-panic (var-get token-a)) u0)
    (map-set collected-protocol-fees (unwrap-panic (var-get token-b)) u0)
    
    ;; Notify revenue distributor
    (if (> fee-a u0)
        ;; Skip revenue distributor for enhanced deployment 
        true
        true)
    
    (if (> fee-b u0)
        ;; Skip revenue distributor for enhanced deployment
        true
        true)
    
    (ok (tuple (fee-a fee-a) (fee-b fee-b)))))

(define-public (update-reward-distribution)
  (begin
    ;; Integration with enhanced tokenomics reward system - simplified for enhanced deployment
    (ok true)))

;; Administrative functions
(define-public (initialize (token-a-addr principal) (token-b-addr principal) (fee-bps uint) (factory-addr principal))
  (begin
    ;; This function should only be called once, by the factory that created this pool.
    (asserts! (is-eq tx-sender factory-addr) (err ERR_UNAUTHORIZED))
    (asserts! (is-none (var-get token-a)) (err ERR_NOT_INITIALIZED)) ;; ERR_ALREADY_INITIALIZED

    (var-set factory factory-addr)
    (var-set token-a (some token-a-addr))
    (var-set token-b (some token-b-addr))
    (var-set lp-fee-bps fee-bps)
    (ok true)
  )
)

(define-public (set-paused (pause bool))
  (begin
    (asserts! (is-eq tx-sender (var-get factory)) ERR_UNAUTHORIZED)
    (var-set paused pause)
    (print (tuple (event "pool-pause-changed") (paused pause)))
    (ok true)))

(define-public (set-fees (lp-fee uint) (protocol-fee uint))
  (begin
    (asserts! (is-eq tx-sender (var-get factory)) ERR_UNAUTHORIZED)
    (asserts! (<= lp-fee u1000) ERR_INVALID_AMOUNT) ;; Max 10%
    (asserts! (<= protocol-fee u100) ERR_INVALID_AMOUNT) ;; Max 1%
    (var-set lp-fee-bps lp-fee)
    (var-set protocol-fee-bps protocol-fee)
    (ok true)))

;; (int-to-ascii) helper removed; not used and caused parsing issues

;; Initialize cumulative price tracking
(map-set last-update-time "price-a" block-height)
(map-set last-update-time "price-b" block-height)
'
error: Tried to close list which isn't open.
error: Tried to close list which isn't open.
error: Failed to lex input remainder: ''accrue-interest (list asset))
)

;; Calculates the total value of a user's collateral, adjusted by collateral factors.
(define-private (get-total-collateral-value-in-usd (user principal))
  (let ((supported-assets (map-keys user-collateral-assets)))
    (fold
      (lambda (asset-tuple total-value)
        (let ((asset (get-in-tuple? asset-tuple { asset: principal })))
          (if (default-to false (map-get? user-collateral-assets { user: user, asset: asset }))
            (let ((asset-info (unwrap! (map-get? supported-assets { asset: asset }) (err u0)))
                  (balance (default-to u0 (map-get? user-supply-balances { user: user, asset: asset })))
                  (price (unwrap! (get-asset-price asset) (err u0))))
              (+ total-value (/ (* balance (get collateral-factor asset-info) price) (* PRECISION PRECISION)))
            )
            total-value
          )
        )
      )
      supported-assets
      u0
    )
  )
)

;; Calculates the total value of a user's borrows.
(define-private (get-total-borrow-value-in-usd (user principal))
  (let ((borrowed-assets (map-keys user-borrow-balances)))
     (fold
      (lambda (asset-tuple total-value)
        (let ((asset (get-in-tuple? asset-tuple { asset: principal })))
          (let ((balance (default-to u0 (map-get? user-borrow-balances { user: user, asset: asset })))
                (price (unwrap! (get-asset-price asset) (err u0))))
            (+ total-value (/ (* balance price) PRECISION))
          )
        )
      )
      borrowed-assets
      u0
    )
  )
)

;; --- Health Factor Calculation ---
(define-read-only (get-health-factor (user principal))
  (let ((collateral-value (get-total-collateral-value-in-usd user))
        (borrow-value (get-total-borrow-value-in-usd user)))
    (if (> borrow-value u0)
      (ok (/ (* collateral-value PRECISION) borrow-value))
      (ok u18446744073709551615) ;; max-uint (2^64 - 1)
    )
  )
)

;; --- Core Functions ---

(define-private (call-circuit-breaker-success)
  (match (var-get circuit-breaker-contract)
    breaker (try! (contract-call? breaker 'record-success (list LENDING_SERVICE)))
    none    true
  )
)

(define-private (call-circuit-breaker-failure)
  (match (var-get circuit-breaker-contract)
    breaker (try! (contract-call? breaker 'record-failure (list LENDING_SERVICE)))
    none    true
  )
)

(define-public (supply (asset principal) (amount uint))
  (match (supply-internal asset amount)
    (ok result)
      (begin
        (try! (call-circuit-breaker-success))
        (ok result)
      )
    (err error-code)
      (begin
        (try! (call-circuit-breaker-failure))
        (err error-code)
      )
  )
)

(define-private (supply-internal (asset-principal principal) (amount uint))
  (begin
    (try! (check-not-paused))
    (match (var-get circuit-breaker-contract)
      breaker (try! (contract-call? breaker 'check-circuit-state (list LENDING_SERVICE)))
      none    true
    )
    (asserts! (> amount u0) ERR_ZERO_AMOUNT)
    (asserts! (is-some (map-get? supported-assets { asset: asset-principal })) ERR_INVALID_ASSET)
    (try! (accrue-interest asset-principal))

    ;; Transfer asset from user to this contract
    (let ((asset-trait (contract-of asset-principal)))
        (try! (contract-call? asset-trait 'transfer (list amount tx-sender (as-contract tx-sender) none)))
    )

    ;; Update user's supply balance
    (let ((current-balance (default-to u0 (map-get? user-supply-balances { user: tx-sender, asset: asset-principal }))))
      (map-set user-supply-balances { user: tx-sender, asset: asset-principal } { balance: (+ current-balance amount) })
    )

    ;; By default, new supply is used as collateral
    (map-set user-collateral-assets { user: tx-sender, asset: asset-principal } true)

    (ok true)
  )
)

(define-public (set-circuit-breaker-contract (breaker principal))
  (begin
    (try! (check-is-owner))
    (var-set circuit-breaker-contract (some breaker))
    (ok true)
  )
)

(define-public (withdraw (asset principal) (amount uint))
  (match (withdraw-internal asset amount)
    (ok result)
      (begin
        (try! (call-circuit-breaker-success))
        (ok result)
      )
    (err error-code)
      (begin
        (try! (call-circuit-breaker-failure))
        (err error-code)
      )
  )
)

(define-private (withdraw-internal (asset-principal principal) (amount uint))
  (begin
    (try! (check-not-paused))
    (match (var-get circuit-breaker-contract)
      breaker (try! (contract-call? breaker 'check-circuit-state (list LENDING_SERVICE)))
      none    true
    )
    (asserts! (> amount u0) ERR_ZERO_AMOUNT)
    (try! (accrue-interest asset-principal))
    (let ((current-balance (default-to u0 (map-get? user-supply-balances { user: tx-sender, asset: asset-principal }))))
      (asserts! (>= current-balance amount) ERR_INSUFFICIENT_LIQUIDITY)
      (map-set user-supply-balances { user: tx-sender, asset: asset-principal } { balance: (- current-balance amount) })
      (let ((health (unwrap! (get-health-factor tx-sender) ERR_HEALTH_CHECK_FAILED)))
        (asserts! (>= health PRECISION) ERR_INSUFFICIENT_COLLATERAL)
      )
      (let ((asset-trait (contract-of asset-principal)))
        (try! (as-contract (contract-call? asset-trait 'transfer (list amount (as-contract tx-sender) tx-sender none))))
      )
      (ok true)
    )
  )
)

(define-public (borrow (asset principal) (amount uint))
  (match (borrow-internal asset amount)
    (ok result)
      (begin
        (try! (call-circuit-breaker-success))
        (ok result)
      )
    (err error-code)
      (begin
        (try! (call-circuit-breaker-failure))
        (err error-code)
      )
  )
)

(define-private (borrow-internal (asset-principal principal) (amount uint))
  (begin
    (try! (check-not-paused))
    (match (var-get circuit-breaker-contract)
      breaker (try! (contract-call? breaker 'check-circuit-state (list LENDING_SERVICE)))
      none    true
    )
    (asserts! (> amount u0) ERR_ZERO_AMOUNT)
    (try! (accrue-interest asset-principal))
    (let ((current-borrow-value (get-total-borrow-value-in-usd tx-sender))
          (price (unwrap! (get-asset-price asset-principal) (err u0)))
          (additional-borrow-value (/ (* amount price) PRECISION)))
      (let ((new-borrow-value (+ current-borrow-value additional-borrow-value))
            (collateral-value (get-total-collateral-value-in-usd tx-sender)))
        (asserts! (>= collateral-value new-borrow-value) ERR_INSUFFICIENT_COLLATERAL)
      )
    )
    (let ((current-borrow (default-to u0 (map-get? user-borrow-balances { user: tx-sender, asset: asset-principal }))))
      (map-set user-borrow-balances { user: tx-sender, asset: asset-principal } { balance: (+ current-borrow amount) })
    )
    (let ((asset-trait (contract-of asset-principal)))
      (try! (as-contract (contract-call? asset-trait 'transfer (list amount (as-contract tx-sender) tx-sender none))))
    )
    (ok true)
  )
)

(define-public (repay (asset principal) (amount uint))
  (match (repay-internal asset amount)
    (ok result)
      (begin
        (try! (call-circuit-breaker-success))
        (ok result)
      )
    (err error-code)
      (begin
        (try! (call-circuit-breaker-failure))
        (err error-code)
      )
  )
)

(define-private (repay-internal (asset-principal principal) (amount uint))
  (begin
    (try! (check-not-paused))
    (match (var-get circuit-breaker-contract)
      breaker (try! (contract-call? breaker 'check-circuit-state (list LENDING_SERVICE)))
      none    true
    )
    (asserts! (> amount u0) ERR_ZERO_AMOUNT)
    (try! (accrue-interest asset-principal))
    (let ((current-borrow (default-to u0 (map-get? user-borrow-balances { user: tx-sender, asset: asset-principal }))))
      (let ((repay-amount (min amount current-borrow)))
        (let ((asset-trait (contract-of asset-principal)))
          (try! (contract-call? asset-trait 'transfer (list repay-amount tx-sender (as-contract tx-sender) none)))
        )
        (map-set user-borrow-balances { user: tx-sender, asset: asset-principal } { balance: (- current-borrow repay-amount) })
        (ok true)
      )
    )
  )
)

;; --- Liquidation ---
;; This function can only be called by the authorized loan-liquidation-manager contract.
(define-public (liquidate (liquidator principal) (borrower principal) (repay-asset principal) (collateral-asset principal) (repay-amount uint))
  (begin
    (asserts! (is-eq tx-sender (var-get loan-liquidation-manager-contract)) ERR_UNAUTHORIZED)
    (try! (check-not-paused))

    (let ((repay-asset-principal (contract-of repay-asset))
          (collateral-asset-principal (contract-of collateral-asset)))
      
      ;; Accrue interest for both assets
      (try! (accrue-interest repay-asset-principal))
      (try! (accrue-interest collateral-asset-principal))

      ;; Check health factor
      (let ((health (unwrap! (get-health-factor borrower) ERR_HEALTH_CHECK_FAILED)))
        (asserts! (< health PRECISION) ERR_POSITION_HEALTHY)
      )

      ;; Determine amount to repay
      (let ((borrow-balance (default-to u0 (map-get? user-borrow-balances { user: borrower, asset: repay-asset-principal })))
            (close-factor u500000000000000000) ;; 50%
            (max-repayable (/ (* borrow-balance close-factor) PRECISION)))
        (let ((actual-repay-amount (min repay-amount max-repayable)))
          
          ;; Calculate collateral to seize
          (let ((repay-price (unwrap! (get-asset-price repay-asset-principal) (err u0)))
                (collateral-price (unwrap! (get-asset-price collateral-asset-principal) (err u0)))
                (liquidation-bonus (get liquidation-bonus (unwrap! (map-get? supported-assets { asset: collateral-asset-principal }) (err u0)))))
            (let ((repay-value-in-usd (/ (* actual-repay-amount repay-price) PRECISION))
                  (bonus-value (/ (* repay-value-in-usd liquidation-bonus) PRECISION))
                  (seize-value-in-usd (+ repay-value-in-usd bonus-value)))
              (let ((collateral-to-seize (/ (* seize-value-in-usd PRECISION) collateral-price)))

                (let ((borrower-collateral (default-to u0 (map-get? user-supply-balances { user: borrower, asset: collateral-asset-principal }))))
                  (asserts! (>= borrower-collateral collateral-to-seize) ERR_INSUFFICIENT_COLLATERAL)

                  ;; --- EFFECTS ---
                  ;; 1. Liquidator repays borrower's debt
                  (try! (contract-call? repay-asset 'transfer (list actual-repay-amount liquidator (as-contract tx-sender) none)))
                  (map-set user-borrow-balances { user: borrower, asset: repay-asset-principal } { balance: (- borrow-balance actual-repay-amount) })
                  
                  ;; 2. Liquidator receives borrower's collateral
                  (map-set user-supply-balances { user: borrower, asset: collateral-asset-principal } { balance: (- borrower-collateral collateral-to-seize) })

                  ;; --- INTERACTION ---
                  (try! (as-contract (contract-call? collateral-asset 'transfer (list collateral-to-seize (as-contract tx-sender) liquidator none))))

                  (print {
                    event: "liquidation",
                    liquidator: liquidator,
                    borrower: borrower,
                    repay-asset: repay-asset-principal,
                    collateral-asset: collateral-asset-principal,
                    debt-repaid: actual-repay-amount,
                    collateral-seized: collateral-to-seize
                  })
                  (ok true)
                )
              )
            )
          )
        )
      )
    )
  )
)

;; --- Admin Functions ---
(define-public (set-paused (new-paused bool))
  (begin
    (try! (check-is-owner))
    (var-set paused new-paused)
    (ok true)
  )
)

(define-public (add-asset (asset principal) (collateral-factor uint) (liquidation-threshold uint) (liquidation-bonus uint))
  (begin
    (try! (check-is-owner))
    (asserts! (is-none (map-get? supported-assets { asset: asset })) ERR_ALREADY_SET)
    (map-set supported-assets { asset: asset }
      {
        collateral-factor: collateral-factor,
        liquidation-threshold: liquidation-threshold,
        liquidation-bonus: liquidation-bonus
      }
    )
    (ok true)
  )
)

(define-public (set-loan-liquidation-manager (manager principal))
  (begin
    (try! (check-is-owner))
    (var-set loan-liquidation-manager-contract manager)
    (ok true)
  )
)
'
x 5 errors detected

----------------------------
Hint: what's next?
Once you are ready to write TypeScript unit tests for your contract, run the following command:

  $ npm install
  $ npm test
    Run all run tests in the ./tests folder.

Find more information on testing with Clarinet here: https://docs.hiro.so/stacks/clarinet-js-sdk
These hints can be disabled in the ~/.clarinet/clarinetrc.toml file.
  $ mkdir -p ~/.clarinet; echo "enable_hints = false" >> ~/.clarinet/clarinetrc.toml
----------------------------
