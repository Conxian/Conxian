;; math-lib-advanced.clar
;; Advanced mathematical library with essential DeFi functions
;; Standalone implementation without dependencies

;; ===== ERROR CODES =====
(define-constant ERR_INVALID_INPUT (err u1001))
(define-constant ERR_OVERFLOW (err u1002))
(define-constant ERR_UNDERFLOW (err u1003))
(define-constant ERR_PRECISION_LOSS (err u1004))

;; ===== CONSTANTS =====
;; Fixed-point precision constant (18 decimal places)
(define-constant PRECISION u1000000000000000000)
(define-constant UINT_MAX u340282366920938463463374607431768211455)  ;; 2^128 - 1

;; Small constants for common values
(define-constant u0 u0)
(define-constant u1 PRECISION)
(define-constant u2 (* u1 2))
(define-constant u3 (* u1 3))
(define-constant u4 (* u1 4))
(define-constant u5 (* u1 5))
(define-constant u10 (* u1 10))

;; Mathematical constants in 18-decimal fixed point
(define-constant E_FIXED u2718281828459045235)  ;; e ~ 2.718281828459045235
(define-constant LN2 u6931471805599453094)      ;; ln(2) * 1e18
(define-constant HALF_PRECISION u500000000000000000)  ;; 0.5 * 1e18

;; ===== SAFE MATH OPERATIONS =====
;; These are placed first as they're used by most other functions

;; Safe addition with overflow check
(define-read-only (safe-add (a uint) (b uint))
  (let ((sum (+ a b)))
    (if (or (>= sum a) (>= sum b))
      (ok sum)
      (err ERR_OVERFLOW)
    )
  )
)

;; Safe subtraction with underflow check
(define-read-only (safe-sub (a uint) (b uint))
  (if (>= a b)
    (ok (- a b))
    (err ERR_UNDERFLOW)
  )
)

;; Safe multiplication with overflow check
(define-read-only (safe-mul (a uint) (b uint))
  (if (or (is-eq a u0) (is-eq b u0))
    (ok u0)
    (let ((product (* a b)))
      (if (or (<= product a) (<= product b))
        (ok product)
        (err ERR_OVERFLOW)
      )
    )
  )
)

;; Fixed-point division with precision handling
(define-read-only (div-down (a uint) (b uint))
  (if (is-eq b u0)
    (err ERR_INVALID_INPUT)
    (ok (/ (* a PRECISION) b)))
)

;; Alias for div-down to maintain compatibility
(define-read-only (safe-div (a uint) (b uint))
  (div-down a b)
)

;; Fixed-point multiplication with precision handling
(define-read-only (mul-down (a uint) (b uint))
  (if (or (is-eq a u0) (is-eq b u0))
    (ok u0)
    (let ((result (/ (* a b) PRECISION)))
      (if (is-eq result u0)
        (err ERR_UNDERFLOW)
        (ok result)
      )
    )
  )
)

;; Safe modulo operation
(define-read-only (safe-mod (a uint) (b uint))
  (if (is-eq b u0)
    (err ERR_INVALID_INPUT)
    (ok (mod a b))
  )
)

;; ===== UTILITY FUNCTIONS =====

(define-read-only (min (a uint) (b uint))
  (if (< a b) a b))

(define-read-only (max (a uint) (b uint))
  (if (> a b) a b))

(define-read-only (average (a uint) (b uint))
  (unwrap! (div-down (unwrap! (safe-add a b) (err ERR_OVERFLOW)) u2) (err ERR_UNDERFLOW)))

(define-read-only (abs-int (x int))
  (if (< x 0)
    (* x -1)
    x
  )
)

(define-read-only (abs-uint (x uint))
  x
)

;; ===== FACTORIAL FUNCTION =====
(define-private (factorial (n uint))
  (if (or (is-eq n u0) (is-eq n u1))
    (ok u1)
    (let ((prev (unwrap! (factorial (unwrap! (safe-sub n u1) (err ERR_UNDERFLOW))) (err ERR_OVERFLOW))))
      (safe-mul n prev)
    )
  )
)

;; ===== INTEGER SQUARE ROOT (Newton's method) =====
(define-private (sqrt-iter (n uint) (guess uint) (prev-guess uint))
  (if (or (is-eq guess prev-guess) (<= (abs-uint (- guess prev-guess)) u1))
    guess
    (let ((next-guess (average guess (unwrap! (div-down n guess) (err ERR_OVERFLOW)))))
      (sqrt-iter n next-guess guess)
    )
  )
)

(define-read-only (sqrt-integer (n uint))
  (if (is-eq n u0)
    (ok u0)
    (let ((initial-guess (max u1 (unwrap! (div-down n u2) (err ERR_OVERFLOW)))))
      (ok (sqrt-iter n initial-guess u0))
    )
  )
)

;; ===== FIXED-POINT SQUARE ROOT (Babylonian method) =====
(define-read-only (sqrt-fixed (x uint))
  (if (or (is-eq x u0) (is-eq x u1))
    (ok x)
    (let (
      (guess (unwrap! (div-down x u2) (err ERR_OVERFLOW)))
      (result (unwrap! (sqrt-iter x guess u0) (err ERR_UNDERFLOW)))
    )
      (ok result)
    )
  )
)

;; ===== FIXED-POINT POWER FUNCTION =====
(define-read-only (pow-fixed (base uint) (exp uint))
  (if (is-eq exp u0)
    (ok PRECISION) ;; x^0 = 1
    (if (is-eq exp PRECISION)
      (ok base)    ;; x^1 = x
      (if (is-eq (mod exp u2) u0)
        ;; Even exponent: x^2n = (x^2)^n
        (let ((x-squared (unwrap! (mul-down base base) (err ERR_OVERFLOW))))
          (pow-fixed x-squared (unwrap! (div-down exp u2) (err ERR_UNDERFLOW)))
        )
        ;; Odd exponent: x^(2n+1) = x * (x^2)^n
        (let* (
          (x-squared (unwrap! (mul-down base base) (err ERR_OVERFLOW)))
          (exp-half (unwrap! (div-down (unwrap! (safe-sub exp PRECISION) (err ERR_UNDERFLOW)) u2) (err ERR_UNDERFLOW)))
          (pow-half (unwrap! (pow-fixed x-squared exp-half) (err ERR_OVERFLOW)))
        )
          (mul-down base pow-half)
        )
      )
    )
  )
)

;; ===== EXPONENTIAL FUNCTION =====

;; Helper function for exp-fixed: calculate e^n where n is an integer
(define-private (exp-integer (n uint))
  (if (is-eq n u0)
    (ok PRECISION)
    (let* (
      (half (unwrap! (div-down n u2) (err ERR_UNDERFLOW)))
      (half-exp (unwrap! (exp-integer half) (err ERR_OVERFLOW)))
      (square (unwrap! (mul-down half-exp half-exp) (err ERR_OVERFLOW)))
    )
      (if (is-eq (mod n u2) u0)
        (ok square)
        (mul-down square E_FIXED)
      )
    )
  )
)

;; Helper function for exp-fixed: calculate e^x where 0 <= x < 1
(define-private (exp-fractional (x uint))
  (let* (
    (x-sq (unwrap! (mul-down x x) (err ERR_OVERFLOW)))
    (x-cu (unwrap! (mul-down x-sq x) (err ERR_OVERFLOW)))
    (t1 (unwrap! (safe-add (unwrap! (div-down x-cu (unwrap! (factorial u3) (err ERR_UNDERFLOW))) (err ERR_UNDERFLOW))
                          (unwrap! (safe-add x (unwrap! (div-down x-sq u2) (err ERR_UNDERFLOW))) (err ERR_OVERFLOW))) (err ERR_OVERFLOW)))
  )
    (ok (unwrap! (safe-add PRECISION t1) (err ERR_OVERFLOW)))
  )
)

;; Main exponential function
(define-read-only (exp-fixed (x uint))
  (if (is-eq x u0)
    (ok PRECISION)  ;; e^0 = 1
    (let* (
      (negative (if (> x PRECISION) true false))
      (x-abs (if negative (unwrap! (safe-sub (unwrap! (safe-mul u2 PRECISION) (err ERR_OVERFLOW)) x) (err ERR_UNDERFLOW)) x))
      (integer (unwrap! (div-down x-abs PRECISION) (err ERR_UNDERFLOW)))
      (fractional (unwrap! (safe-mod x-abs PRECISION) (err ERR_UNDERFLOW)))
      (exp-int (exp-integer integer))
      (exp-frac (exp-fractional fractional))
      (result (unwrap! (mul-down exp-int exp-frac) (err ERR_OVERFLOW)))
    )
      (if negative
        (div-down PRECISION result)
        (ok result)
      )
    )
  )
)

;; ===== NATURAL LOGARITHM =====

;; Helper function for ln-fixed: count number of divisions by 2 needed to get x <= 1.0
(define-private (ln2-iter (x uint) (count uint))
  (if (<= x PRECISION)
    count
    (ln2-iter (unwrap! (div-down x u2) (err ERR_UNDERFLOW)) (unwrap! (safe-add count PRECISION) (err ERR_OVERFLOW)))
  )
)

;; Helper function for ln-fixed: Taylor series approximation of ln((1+z)/(1-z))
(define-private (ln2-approx (t uint) (t-sq uint) (n uint) (p uint) (i uint))
  (if (>= i u10)  ;; 10 iterations for good precision
    (ok p)
    (let* (
      (term (unwrap! (div-down 
        (unwrap! (pow-fixed t-sq n) (err ERR_OVERFLOW)) 
        (unwrap! (safe-mul u2 (unwrap! (safe-add i u1) (err ERR_OVERFLOW))) (err ERR_OVERFLOW))) 
        (err ERR_UNDERFLOW)))
      (new-p (if (is-eq (mod n u2) u0)
                (unwrap! (safe-add p term) (err ERR_OVERFLOW))
                (unwrap! (safe-sub p term) (err ERR_UNDERFLOW))
              ))
    )
      (ln2-approx t t-sq (unwrap! (safe-add n PRECISION) (err ERR_OVERFLOW)) new-p (unwrap! (safe-add i PRECISION) (err ERR_OVERFLOW)))
    )
  )
)

;; Main natural logarithm function
(define-read-only (ln-fixed (x uint))
  (if (or (<= x u0))
    (err ERR_INVALID_INPUT)
    (if (is-eq x PRECISION)
      (ok u0)  ;; ln(1) = 0
      (let* (
        (log2 (ln2-iter x u0))
        (y (unwrap! (div-down x (unwrap! (pow-fixed u2 log2) (err ERR_OVERFLOW))) (err ERR_UNDERFLOW)))
        (z (unwrap! (safe-sub y PRECISION) (err ERR_UNDERFLOW)))
        (t (unwrap! (div-down z (unwrap! (safe-add y PRECISION) (err ERR_OVERFLOW))) (err ERR_UNDERFLOW)))
        (t-sq (unwrap! (mul-down t t) (err ERR_OVERFLOW)))
        (p (ln2-approx t t-sq u0 u0 u0))
      )
        (ok (unwrap! (safe-add 
          (unwrap! (mul-down p (unwrap! (safe-mul u2 t) (err ERR_OVERFLOW))) (err ERR_OVERFLOW)) 
          (unwrap! (mul-down log2 LN2) (err ERR_OVERFLOW))) 
          (err ERR_OVERFLOW)))
      )
    )
  )
)
