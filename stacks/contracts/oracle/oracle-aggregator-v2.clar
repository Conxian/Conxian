;; Oracle Aggregator V2;; This contract aggregates prices from multiple oracle sources, calculates TWAP, and detects manipulation.;; --- Constants ---(define-constant ERR_UNAUTHORIZED (err u1003))(define-constant ERR_INVALID_SOURCE (err u6001))(define-constant ERR_NO_SOURCES (err u6002))(define-constant ERR_INVALID_PRICE (err u6003))(define-constant ERR_DEVIATION_TOO_HIGH (err u6004))(define-constant ERR_CIRCUIT_OPEN (err u5000))(define-constant ERR_PRICE_MANIPULATION (err u6005))(define-constant ONE_HOUR_IN_BLOCKS u6);; --- Data Variables ---(define-data-var contract-owner principal tx-sender)(define-data-var circuit-breaker principal .circuit-breaker)(define-data-var oracle-sources (list 20 principal) (list))(define-map prices { token-a: principal, token-b: principal } { price: uint, last-updated: uint })(define-map twap { token-a: principal, token-b: principal } { price: uint, last-updated: uint })(define-map price-history { token-a: principal, token-b: principal } (list 100 uint)) ;; Stores last 100 prices;; --- Public Functions ---(define-public (add-oracle-source (source principal))  (begin    (asserts! (is-eq tx-sender (var-get contract-owner)) ERR_UNAUTHORIZED)    (let ((sources (var-get oracle-sources)))      (if (contains-principal? source sources)        (ok true)        (begin          (var-set oracle-sources (unwrap-panic (as-max-len? (append sources (list source)) u20)))          (ok true)        )      )    )  ))(define-public (remove-oracle-source (source principal))  (begin    (asserts! (is-eq tx-sender (var-get contract-owner)) ERR_UNAUTHORIZED)    (let ((sources (var-get oracle-sources)))      (var-set oracle-sources (filter (lambda ((s principal)) (not (is-eq s source))) sources))      (ok true)    )  ))(define-public (set-circuit-breaker (new-circuit-breaker principal))  (begin    (asserts! (is-eq tx-sender (var-get contract-owner)) ERR_UNAUTHORIZED)    (var-set circuit-breaker new-circuit-breaker)    (ok true)  ))(define-public (update-price (token-a principal) (token-b principal))  (let (    (sources (var-get oracle-sources))    (prices-list (try! (get-prices-from-sources sources token-a token-b)))    (median-price (try! (calculate-median prices-list)))  )    (asserts! (not (try! (check-circuit-breaker))) ERR_CIRCUIT_OPEN)    (asserts! (> (len sources) u0) ERR_NO_SOURCES)    (try! (check-deviation median-price token-a token-b))    (try! (check-manipulation median-price token-a token-b))    (map-set prices { token-a: token-a, token-b: token-b } { price: median-price, last-updated: block-height })    (map-set price-history { token-a: token-a, token-b: token-b } (unwrap-panic (as-max-len? (append (default-to (list) (map-get? price-history { token-a: token-a, token-b: token-b })) median-price) u100)))    (try! (update-twap median-price token-a token-b))    (ok median-price)  ))(define-read-only (get-price (token-a principal) (token-b principal))  (ok (get price (unwrap! (map-get? prices { token-a: token-a, token-b: token-b }) (err ERR_INVALID_PRICE)))))(define-read-only (get-twap (token-a principal) (token-b principal))  (ok (get price (unwrap! (map-get? twap { token-a: token-a, token-b: token-b }) (err ERR_INVALID_PRICE)))));; --- Private Helper Functions ---(define-private (check-circuit-breaker)  (contract-call? (var-get circuit-breaker) is-circuit-open))(define-private (get-prices-from-sources (sources (list 20 principal)) (token-a principal) (token-b principal))  (ok (fold (lambda (source acc)    (match (contract-call? source get-price token-a token-b)      (success price) (append acc (list price))      (error error-code) acc    )  ) sources (list))))(define-private (calculate-median (prices (list 20 uint)))  (let ((sorted (sort < prices)))    (let ((len (len sorted)))      (if (is-eq (mod len u2) u1)        (ok (unwrap-panic (element-at sorted (/ (- len u1) u2))))        (ok (/ (+ (unwrap-panic (element-at sorted (/ len u2))) (unwrap-panic (element-at sorted (- (/ len u2) u1)))) u2))      )    )  ))(define-private (check-deviation (new-price uint) (token-a principal) (token-b principal))  (match (map-get? prices { token-a: token-a, token-b: token-b })    old-price-data      (let (        (old-price (get price old-price-data))        (deviation (abs (- (to-int new-price) (to-int old-price))))        (threshold (/ (* old-price u500) u10000)) ;; 5% deviation threshold      )        (asserts! (<= deviation threshold) ERR_DEVIATION_TOO_HIGH)        (ok true)      )    (ok true) ;; No previous price to compare, so no deviation  ))(define-private (update-twap (new-price uint) (token-a principal) (token-b principal))  (let (    (current-block block-height)    (twap-period ONE_HOUR_IN_BLOCKS)  )    (match (map-get? twap { token-a: token-a, token-b: token-b })      old-twap-data        (let (          (old-twap (get price old-twap-data))          (last-updated (get last-updated old-twap-data))          (blocks-since-update (- current-block last-updated))        )          (if (> blocks-since-update u0)            (let (              (new-twap (/ (+ (* old-twap (- twap-period blocks-since-update)) (* new-price blocks-since-update)) twap-period))            )              (map-set twap { token-a: token-a, token-b: token-b } { price: new-twap, last-updated: current-block })              (ok true)            )            (ok true) ;; No block passed, no TWAP update needed          )        )      (begin        ;; First TWAP update        (map-set twap { token-a: token-a, token-b: token-b } { price: new-price, last-updated: current-block })        (ok true)      )    )  ))(define-constant MANIPULATION_DEVIATION_THRESHOLD u1000) ;; 10% deviation threshold for manipulation(define-private (check-manipulation (new-price uint) (token-a principal) (token-b principal))  (let (    (history (default-to (list) (map-get? price-history { token-a: token-a, token-b: token-b })))  )    (if (>= (len history) u5) ;; Only check if enough history is available      (let (        (sum (fold + history u0))        (average (/ sum (len history)))        (deviation (abs (- (to-int new-price) (to-int average))))        (threshold (/ (* average MANIPULATION_DEVIATION_THRESHOLD) u10000))      )        (asserts! (<= deviation threshold) ERR_PRICE_MANIPULATION)        (ok true)      )      (ok true) ;; Not enough history to check for manipulation    )  ))